---
layout:     post
title:      算法篇
subtitle:   推荐工具
date:       2019-11-06
author:     JackyCJ
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - Python
    - 算法

---

# 算法篇

## 排序算法
|排序算法|平均时间复杂度T(n)|最好情况|最坏情况|稳定度|空间复杂度S(n)|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|[冒泡排序](#bubblesort)|O(n^2)|O(n)|O(n^2)|稳定|O(1)|
|[选择排序](#selectsort)|O(n^2)|O(n^2)|O(n^2)|不稳定|O(1)|
|[插入排序](#insertsort)|O(n^2)|O(n^2)|O(n^2)|稳定|O(1)|
|[快速排序](#quicksort)|O(n^2)|O(n^2)|O(nlog2n)|不稳定|O(log2n)-O(n)|
|[希尔排序](#shellsort)|O(nlogn)|O(nlog2n)|O(nlog2n)|不稳定|O(1)|
|[归并排序](#mergesort)|O(nlogn)|O(nlogn)|O(nlogn)|稳定|O(n)|
|[堆排序](#heapsort)|O(nlogn)|O(nlogn)|O(nlogn)|不稳定|O(n)|
|[计数排序](#countsort)|O(n+k)|O(n+k)|O(n+k)|稳定|O(k)|
|[桶排序](#bucketsort)|O(n+k)|O(n+k)|O(n2)|稳定|O(n+k)|
|[基数排序](#basesort)|O(n*k)|O(n*k)|O(n*k)|稳定|O(n+k)|

+ 冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。
+ 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。



<div id="bubblesort"></div>
### 冒泡排序：
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

1. 算法步骤:
    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
    3. 针对所有的元素重复以上的步骤，除了最后一个。
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8odw22ootg30my075thy.gif)
3. 范例:

```
def bubblesort(arr):
    min = max = 0
    for i in range(1, len(arr)):
        for j in range(0, len(arr) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                min += 1
            max += 1
    return arr, len(arr), min, max
```
+ T(n)=n+n-1+...+1≈(n^2)/2≈(n^2)
+ S(n)=O(1)

<div id="selectsort"></div>
### 选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

1. 算法步骤
    1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    3. 重复第二步，直到所有元素均排序完毕。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8oelumkp7g30mj06wdsb.gif)
3. 范例:

```
def selectionsort(arr):
    min = max = 1
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
                min += 1
            max += 1
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr, len(arr), min, max
```
+ T(n)=n+n-1+...+1≈(n^2)/2≈(n^2)
+ S(n)=O(1)

<div id="insertsort"></div>
### 插入排序
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

_插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。_

1. 算法步骤
	1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
	2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
2. 动图演示
3. 范例:

```
def insertionsort(arr):
    min = max = 0
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex >= 0 and arr[preIndex] > current:
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
            min += 1
            max += 1
        arr[preIndex+1] = current
    return arr, len(arr), min, max
```
+ T(n)=n+n-1+...+1≈(n^2)/2≈(n^2)
+ S(n)=O(1)

<div id="quicksort"></div>
### 快速排序
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n²) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

	快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
	

1. 算法步骤
	1. 从数列中挑出一个元素，称为 “基准”（pivot）;
	2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

2. 动图演示

3. 范例:

```
def quicksort(arr, left=None, right=None):
    left = 0 if not isinstance(left, (int, float)) else left
    right = len(arr)-1 if not isinstance(right, (int, float)) else right
    if left < right:
        partitionIndex = partition(arr, left, right)
        quicksort(arr, left, partitionIndex-1)
        quicksort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while i <= right:
        if arr[i] < arr[pivot]:
            swap(arr, i, index)
            index += 1
        i += 1
    swap(arr, pivot, index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
```

<div id="shellsort"></div>
### 希尔排序
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

    插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；

    但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

1. 算法步骤
    1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
    2. 按增量序列个数 k，对序列进行 k 趟排序；
    3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

2. 动图演示

3. 范例:

```
def shellsort(arr):
    import math
    gap = 1
    while gap < len(arr)/3:
        gap = gap*3+1
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i-gap
            while j >= 0 and arr[j] > temp:
                arr[j+gap] = arr[j]
                j -= gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
```

<div id="mergesort"></div>
### 归并排序
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

    自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；

    自下而上的迭代；

在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：

    However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.

    然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。

说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。

1. 算法步骤
    1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
    2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
    3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
    4. 重复步骤 3 直到某一指针达到序列尾；
    5. 将另一序列剩下的所有元素直接复制到合并序列尾。

2. 动图演示

3. 范例:

```
def mergesort(arr):
    import math
    if len(arr) < 2:
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergesort(left), mergesort(right))


def merge(left, right):
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))
    return result
```

<div id="heapsort"></div>
### 堆排序
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

    大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；

    小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆排序的平均时间复杂度为 Ο(nlogn)。

1. 算法步骤
    1. 创建一个堆 H[0……n-1]；
    2. 把堆首（最大值）和堆尾互换；
    3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
    4. 重复步骤 2，直到堆的尺寸为 1。

2. 动图演示

3. 范例:

```
def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2), -1, -1):
        heapify(arr, i)


def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left < arrLen and arr[left] > arr[largest]:
        largest = left
    if right < arrLen and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)


def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]


def heapsort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1, 0, -1):
        swap(arr, 0, i)
        arrLen -= 1
        heapify(arr, 0)
    return arr
```

<div id="countsort"></div>
### 计数排序
序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

1. 动图演示

2. 范例

```
def countingsort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex = 0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]] = 0
        bucket[arr[i]] += 1
    for j in range(bucketLen):
        while bucket[j] > 0:
            arr[sortedIndex] = j
            sortedIndex += 1
            bucket[j] -= 1
    return arr
```
 
<div id="bucketsort"></div>
### 桶排序
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

    在额外空间充足的情况下，尽量增大桶的数量

    使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

	什么时候最快:当输入的数据可以均匀的分配到每一个桶中。
	
	什么时候最慢:当输入的数据被分配到了同一个桶中。


<div id="basesort"></div>
### 基数排序
基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

1. 基数排序 vs 计数排序 vs 桶排序

	基数排序有两种方法：这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
   + 基数排序：根据键值的每位数字来分配桶；
   + 计数排序：每个桶只存储单一键值；
   + 桶排序：每个桶存储一定范围的数值；
   
2. LSD 基数排序动图演示



## 名词解释

### 算法
+ 算法：解决特定问题的步骤的描述。
+ 特性：
	+ 输入：有零个输入或者多个输入。
	+ 输出：只有一个或者多个输出。
	+ 有穷型性：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面。
	+ 确定性：算法的每一步都有确定的含义而不会出现二义性。
	+ 可行性：算法的每一步都可以通过有限次数完成。
+ 要求：
	+ 正确性、可读性、健壮性、时间效率高而且空间使用率低、简单性。
	+ 算法的复杂度分为时间复杂度和空间复杂度。 

### 时间复杂度：
+ 时间复杂度：时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为:T(n)=O(f(n));
+ 在一个算法存在最好、平均、最坏三种情况，我们一般关注的是最坏情况，原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。 
+ 常见的时间复杂度：
	+ 常数阶 T(n) = O(1)
	+ 线性阶 T(n) = O(n)
	+ 对数阶 T(n) = O(logn)
	+ 二维阶 T(n) = O(nlogn)
	+ 平方阶 T(n) = O(n^2)
	+ 立方阶 T(n) = O(n^3)
	+ ...
	+ k次方阶O(n^k)
	+ 指数阶 T(n) = O(2^n)
+ n：数据规模
+ 效率对比 O(1) < O(logn) < O(n) < O(n²)

其中，	

1. O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k)为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。
2. O(2^n)，指数阶时间复杂度，该种不实用。
3. 对数阶O(log2n),线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高。

### 空间复杂度：
+ 空间复杂度：是对一个算法在运行过程中临时占用存储空间的度量，一个算法在计算机存储器上所占用的存储空间包括存储算法本身所占用的空间，算数和输入输出所占用的存储空间以及临时占用存储空间三个部分。算法的输入输出数据所占用的存储空间是由待解决的问题来决定的，通过参数表由调用函数而来，它随本算法的不同而改变，存储算法本身所占用的存储空间有算法的书写长短成正比。算法在运行过程中占用的临时空间由不同的算法决定。

### 稳定度：
+  稳定度：通俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。再简单具体一点，如果A(i) == A(j)，A(i) 原来在 A(j) 位置前，排序后 (Ai) 仍然是在 A(j) 位置前。 

分析一下常见的排序算法的稳定性，每个都给出简单的理由。 

```
（1）冒泡排序 
冒泡排序就是把小的元素往前调（或者把大的元素往后调）。注意是相邻的两个元素进行比较，而且是否需要交换也发生在这两个元素之间。

所以，如果两个元素相等，我想你是不会再无聊地把它们俩再交换一下。

如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个元素相邻起来，最终也不会交换它俩的位置，所以相同元素经过排序后顺序并没有改变。

所以冒泡排序是一种稳定排序算法。 
```
```
（2）选择排序

选择排序即是给每个位置选择待排序元素中当前最小的元素。比如给第一个位置选择最小的，在剩余元素里面给第二个位置选择次小的，

依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。

那么，在一趟选择时，如果当前锁定元素比后面一个元素大，而后面较小的那个元素又出现在一个与当前锁定元素相等的元素后面，那么交换后位置顺序显然改变了。

呵呵！比较拗口，举个例子：序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。

所以选择排序不是一个稳定的排序算法。 
```
```
（3）插入排序

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，也就是第一个元素（默认它有序）。

比较是从有序序列的末尾开始，也就是把待插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面。

否则一直往前找直到找到它该插入的位置。如果遇见一个与插入元素相等的，那么把待插入的元素放在相等元素的后面。

所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序仍是排好序后的顺序，所以插入排序是稳定的。 
```
```
（4）快速排序

快速排序有两个方向，左边的i下标一直往右走（当条件a[i] <= a[center_index]时），其中center_index是中枢元素的数组下标，一般取为数组第0个元素。

而右边的j下标一直往左走（当a[j] > a[center_index]时）。

如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。交换a[j]和a[center_index]，完成一趟快速排序。

在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11 

现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱。

所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。 
```
```
（5）归并排序

归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换)，

然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。

可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。

那么，在短的有序序列合并的过程中，稳定是是否受到破坏？

没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。

所以，归并排序也是稳定的排序算法。 
```
```
（6）基数排序

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。

有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序结果就是高优先级高的在前，高优先级相同的情况下低优先级高的在前。

基数排序基于分别排序，分别收集，所以其是稳定的排序算法。
```
```
（7）希尔排序

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；

当元素基本有序时，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(N^2)好一些。

由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，

但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。

所以shell排序是不稳定的排序算法。 
```
```
（8）堆排序

我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。

在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。

但当为n/2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。

有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。

所以，堆排序不是稳定的排序算法。
```


### 如何计算时间复杂度(C++代码范例)

```
//循环了n*n次，当然是O(n^2)
for(i=1;i<=n;i++)   
    for(j=1;j<=n;j++)
         s++;
         
//循环了(n+n-1+n-2+...+1)≈(n^2)/2，因为时间复杂度是不考虑系数的，所以也是O(n^2)
for(i=1;i<=n;i++)
    for(j=i;j<=n;j++)
         s++;

//循环了(1+2+3+...+n)≈(n^2)/2,当然也是O(n^2)
for(i=1;i<=n;i++)    
	for(j=1;j<=i;j++)
         s++;
         
//循环了n-1≈n次，所以是O(n)
i=1;k=0;
while(i<=n-1){
   k+=10*i;
i++; }

//循环了(1^2+2^2+3^2+...+n^2)=n(n+1)(2n+1)/6(这个公式要记住哦)≈(n^3)/3，不考虑系数，自然是O(n^3)
for(i=1;i<=n;i++)
     for(j=1;j<=i;j++)
         for(k=1;k<=j;k++)
               x=x+1;

```

# 参考
+ [python实现十大经典算法](https://www.cnblogs.com/123blog/p/10405443.html)


