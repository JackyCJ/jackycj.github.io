---
layout:     post
title:      算法篇
subtitle:   推荐工具
date:       2019-11-06
author:     JackyCJ
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - Python
    - 算法

---

# 算法篇

## 排序算法
|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|
|:-----:|:-----:|:-----:|:-----:|:-----:|
|[冒泡排序](#bubblesort)|O(n^2)|O(n)|O(n^2)|O(1)|
|[选择排序](#selectsort)|O(n^2)|O(n)|O(n^2)|O(1)|
|||||
|||||

名词解释：

+ 时间复杂度：
	+ 线性阶排序 T(n) = O(n)
	+ 对数阶排序 T(n) = O(logn)
	+ 平方阶排序 T(n) = O(n^2)
+ n：数据规模
+ 空间复杂度：


如何计算时间复杂度(C++代码范例)

```
//循环了n*n次，当然是O(n^2)
for(i=1;i<=n;i++)   
    for(j=1;j<=n;j++)
         s++;
         
//循环了(n+n-1+n-2+...+1)≈(n^2)/2，因为时间复杂度是不考虑系数的，所以也是O(n^2)
for(i=1;i<=n;i++)
    for(j=i;j<=n;j++)
         s++;

//循环了(1+2+3+...+n)≈(n^2)/2,当然也是O(n^2)
for(i=1;i<=n;i++)    
	for(j=1;j<=i;j++)
         s++;
         
//循环了n-1≈n次，所以是O(n)
i=1;k=0;
while(i<=n-1){
   k+=10*i;
i++; }

//循环了(1^2+2^2+3^2+...+n^2)=n(n+1)(2n+1)/6(这个公式要记住哦)≈(n^3)/3，不考虑系数，自然是O(n^3)
for(i=1;i<=n;i++)
     for(j=1;j<=i;j++)
         for(k=1;k<=j;k++)
               x=x+1;

```
1.常见的时间复杂度
按数量级递增排列，常见的时间复杂度有：

+ 常数阶O(1)
+ 对数阶O(log2n)
+ 线性阶O(n)
+ 线性对数阶O(nlog2n)
+ 平方阶O(n^2)
+ 立方阶O(n^3)
+ ...
+ k次方阶O(n^k)
+ 指数阶O(2^n)

其中，

1. O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k)为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。
2. O(2^n)，指数阶时间复杂度，该种不实用。
3. 对数阶O(log2n),线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高。


+ 效率对比 O(1)< O(logn)< O(n)< O(n^2)

<div id="bubblesort"></div>
### 冒泡排序：
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

1. 算法步骤:
    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
    3. 针对所有的元素重复以上的步骤，除了最后一个。
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8odw22ootg30my075thy.gif)
3. 范例:

```
def bubblesort(arr):
    o = 0
    for i in range(1, len(arr)):
        for j in range(0, len(arr) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                o += 1
    return arr, o
```
<div id="selectsort"></div>
### 选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

1. 算法步骤
    1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    3. 重复第二步，直到所有元素均排序完毕。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8oelumkp7g30mj06wdsb.gif)
3. 范例:

```
def selectionsort(arr):
    o = 0
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
                o += 1
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr, o
```
### 插入排序
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

_插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。_

1. 算法步骤
	1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
	2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
2. 动图演示
3. 范例:

```
def insertionsort(arr):
    min = max = 0
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex >= 0 and arr[preIndex] > current:
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
            min += 1
            max += 1
        arr[preIndex+1] = current
    return arr, len(arr), min, max
```

### 快速排序
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

    快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

1. 算法步骤
	1. 从数列中挑出一个元素，称为 “基准”（pivot）;
	2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

2. 动图演示
3. 范例:

```

```



# 参考
+ [python实现十大经典算法](https://www.cnblogs.com/123blog/p/10405443.html)


