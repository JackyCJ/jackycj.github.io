---
layout:     post
title:      算法篇
subtitle:   推荐工具
date:       2019-11-06
author:     JackyCJ
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - Python
    - 算法

---

# 算法篇

## 排序算法
|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|
|:-----:|:-----:|:-----:|:-----:|:-----:|
|[冒泡排序](#bubblesort)|O(n^2)|O(n)|O(n^2)|O(1)|
|[选择排序](#selectsort)||||
|||||
|||||

名词解释：

+ 时间复杂度：
	+ 线性阶排序 T(n) = O(n)
	+ 对数阶排序 T(n) = O(logn)
	+ 平方阶排序 T(n) = O(n^2)
+ n：数据规模
+ 空间复杂度：



```
//循环了n*n次，当然是O(n^2)
for(i=1;i<=n;i++)   
    for(j=1;j<=n;j++)
         s++;
         
//循环了(n+n-1+n-2+...+1)≈(n^2)/2，因为时间复杂度是不考虑系数的，所以也是O(n^2)
for(i=1;i<=n;i++)
    for(j=i;j<=n;j++)
         s++;

//循环了(1+2+3+...+n)≈(n^2)/2,当然也是O(n^2)
for(i=1;i<=n;i++)    
	for(j=1;j<=i;j++)
         s++;
         
//循环了n-1≈n次，所以是O(n)
i=1;k=0;
while(i<=n-1){
   k+=10*i;
i++; }

//循环了(1^2+2^2+3^2+...+n^2)=n(n+1)(2n+1)/6(这个公式要记住哦)≈(n^3)/3，不考虑系数，自然是O(n^3)
for(i=1;i<=n;i++)
     for(j=1;j<=i;j++)
         for(k=1;k<=j;k++)
               x=x+1;

```
1.常见的时间复杂度
按数量级递增排列，常见的时间复杂度有：

+ 常数阶O(1)
+ 对数阶O(log2n)
+ 线性阶O(n)
+ 线性对数阶O(nlog2n)
+ 平方阶O(n^2)
+ 立方阶O(n^3)
+ ...
+ k次方阶O(n^k)
+ 指数阶O(2^n)

其中，

1. O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k)为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。
2. O(2^n)，指数阶时间复杂度，该种不实用。
3. 对数阶O(log2n),线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高。


+ 效率对比 O(1)< O(logn)< O(n)< O(n^2)

<div id="bubblesort"></div>
### 冒泡排序：
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

1. 算法步骤:
    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
    3. 针对所有的元素重复以上的步骤，除了最后一个。
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8odw22ootg30my075thy.gif)
3. 范例:

```
def bubblesort(arr):
    o = 0
    for i in range(1, len(arr)):
        for j in range(0, len(arr) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                o += 1
    return arr, o
```
<div id="selectsort"></div>
### 选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

1. 算法步骤
    1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    3. 重复第二步，直到所有元素均排序完毕。
2. 动图演示:
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8oelumkp7g30mj06wdsb.gif)
3. 范例:

```
def selectionsort(arr):
    o = 0
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
                o += 1
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr, o
```



# 参考
+ [python实现十大经典算法](https://www.cnblogs.com/123blog/p/10405443.html)


